# 2020-7-1 周三

## Redis 简单限流

滑动窗口

```python
def is_action_is_allowed(user_id, action_key, period, max_count):
    key = 'hist:%s:%s' % (user_id, action_key)
    now_ts = int(time.time() * 1000)  # 毫秒时间戳
    with r.pipeline() as pipe:
        #  value:score 都是毫秒时间戳
        pipe.zadd(key, {now_ts: now_ts})
        # 移除时间窗口之前的操作记录
        pipe.zremrangebyscore(key, 0, now_ts - period * 1000)
        # 获取窗口内的行为数量
        pipe.zcard(key)
        # 设置 zet 过期时间，避免冷用户持续占用内存
        pipe.expire(key, period + 1)  # 过期时间再宽限一秒
        _, _, current_count, _ = pipe.execute()
    return current_count <= max_count
```

```python
for i in range(8):
    print(is_action_is_allowed("tabll6", "replay", 60, 5))  # 60秒内限制5次操作
```

返回：

```sh
True
True
True
True
True
False
False
False
```

# 2020-7-2 周四

## Redis 漏斗限流

基本原理就是按照代码中的逻辑来

实际情况是有更加完美的包解决的：`Redis-Cell`

```python
class Funnel(object):

    def __init__(self, capacity, leaking_rate):
        self.capacity = capacity          # 漏斗容量
        self.leaking_rate = leaking_rate  # 流水速率
        self.left_quota = capacity        # 漏斗剩余空间
        self.leaking_ts = time.time()     # 上一次漏水时间

    def  make_space(self):
        now_ts = time.time()
        # 距离上一次漏水的时间
        delta_ts = now_ts - self.leaking_ts
        # 可以腾出的空间
        delta_quota = delta_ts * self.leaking_rate
        # 如果空间不足则下次再说
        if delta_quota < 1:
            return
        self.left_quota += delta_quota  # 增加剩余空间
        self.leaking_ts = now_ts  # 记录漏水时间
        # 剩余空间不得高于容量
        if self.left_quota > self.capacity:
            self.left_quota = self.capacity
    
    def watering(self, quota):
        self.make_space()
        # 判断剩余空间是否足够
        if self.left_quota >= quota:
            self.left_quota -= quota
            return True
        return False
```

```python
funnels = {}  # 所有的漏斗
```

```python
# 检查执行是否被允许
def is_action_allowed(user_id, action_key, capacity, leaking_rate):
    key = '%s:%s' % (user_id, action_key)
    funnel = funnels.get(key)
    if not funnel:
        funnel = Funnel(capacity, leaking_rate)
        funnels[key] = funnel

    return funnel.watering(1)
```

```python
for i in range(20):
    print(is_action_allowed("tabll6", "replay", 15, 5))  # 容量 15， 流水速率 5/s
```

返回：

```python
True
True
True
True
True
True
True
True
True
True
True
True
True
True
True
False
False
False
False
False
```

# 2020-7-3 周五

## Redis-Cell

这个也是需要额外安装并启用的模块

```python
r.execute_command('CL.THROTTLE', "tabll6:get", 15, 10, 20, 1)  # key / 15漏斗容量 / 10 option 10个操作 / 20 seconds 每20秒 / need 1 quota
```

1) (integer) 0   # 0 表示允许，1 表示拒绝  
2) (integer) 15  # 漏斗容量 capacity  
3) (integer) 14  # 漏斗剩余空间 left_quota  
4) (integer) -1  # 如果拒绝了，需要多长时间后再试(漏斗有空间了，单位秒)  
5) (integer) 2   # 多长时间后，漏斗完全空出来(left_quota==capacity，单位秒)  

相关文档：https://github.com/brandur/redis-cell

# 2020-7-6 周一

## 代码圈块复杂度

最近安装了 `SonarLint` 插件，发现项目中非常多的 `function` 被提示需要优化

```php
SonarLint: Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed. [+15 locations] more... (Ctrl+F1)
```

圈复杂度 （`Cyclomatic Complexity`） 是一种代码复杂度的衡量标准，由 `Thomas McCabe` 于 `1976` 年定义。它可以用来衡量一个模块判定结构的复杂程度，数量上表现为独立现行路径条数，也可理解为覆盖所有的可能情况最少使用的测试用例数。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和维护。程序的可能错误和高的圈复杂度有着很大关系。

一般来说圈复杂度` V(G)` 与代码质量的关系如下： 
V(G) ∈ [0 , 10]：代码质量不错； 
V(G) ∈ [11 , 15]：可能存在需要拆分的代码，应当尽可能想措施重构； 
V(G) ∈ [16 , ∞)：必须进行重构；

参考：[圈复杂度详解以及解决圈复杂度常用的方法](https://blog.csdn.net/u010684134/article/details/94412483)

#### 降低圈复杂度

Extract Method（提炼函数）

Substitute Algorithm（替换你的算法）

Decompose Conditional（分解条件式）

Consolidate Conditional Expression（合并条件式）

Consolidate Duplicate Conditional Fragments（合并重复的条件片断）

Remove Control Flag（移除控制标记）

Parameterize Method（令函数携带参数）

# 2020-7-7 周二

## GitLab 与 GitHub 同步

GitHub 最近开启了”北极代码库”计划，会将所有的代码在北极存一份。有点末日种子库的感觉，以后人类还能看到千年前的写BUG

备份还是必要的，防止自建的GitLab有一天挂了，现在打算将GitLab上的代码都同步一份到GitHub上面去

步骤很简单，不过好像基础版的GitLab暂时不支持镜像同步的功能

首先在GitHub上面创建一个新的仓库，公开或者私有都可以，支持两边的查看权限不一致

![](https://tabll-1252262977.cos.ap-shanghai.myqcloud.com/others/gitlab-github-sync1.png)

然后在GitLab中找到仓库的设置->仓库->镜像仓库

![](https://tabll-1252262977.cos.ap-shanghai.myqcloud.com/others/gitlab-github-sync2.png)

填写仓库URL地址，注意这里的仓库URL地址需要拼接上你的用户名

比如 https://XXXXX@github.com/XXXXX/ABC.git

镜像的方向是推送，你也可以反向的从GitHub上面拉取

密码是在GitHub上面生成的Token

![](https://tabll-1252262977.cos.ap-shanghai.myqcloud.com/others/gitlab-github-sync3.png)

完成之后它不会立即同步，可能需要等一会儿，你可以点击立即同步按钮，让它立即执行

这个同步只会同步仓库的代码和commits记录，合并请求ci/cd这些都不会同步过去，目前感觉还是gitlab的ci好用

# 2020-7-8 周三

# 2020-7-9 周四

# 2020-7-10 周五

# 2020-7-13 周一

# 2020-7-14 周二

# 2020-7-15 周三

# 2020-7-16 周四

# 2020-7-17 周五

# 2020-7-20 周一

# 2020-7-21 周二

# 2020-7-22 周三

# 2020-7-23 周四

# 2020-7-24 周五

# 2020-7-27 周一

# 2020-7-28 周二

# 2020-7-29 周三

# 2020-7-30 周四

# 2020-7-31 周五
